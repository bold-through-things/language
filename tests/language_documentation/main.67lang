note welcome to 67lang: the language that gets out of your way!
	buckle up! you're about to discover the most refreshingly minimal yet powerful
	programming language you never knew you needed. this isn't just documentation -
	it's your personal guide through a language designed with one principle: 
	getting shit done elegantly.
	
	why does 67lang exist? because we got tired of languages that pretend to be simple
	but hide complexity behind abstractions. here, what you see is what you get.
	every line of this file both documents AND tests the language. by the end,
	you'll not only understand 67lang - you'll wonder why all languages aren't this clear.

note chapter 1: data types that actually make sense
	forget everything you know about overcomplicated type systems. 67lang gives you
	exactly what you need, nothing more, nothing less.

note integers: numbers without the drama
	when you need a number, you just say so. no int32 vs int64 anxiety here.

local my_number
	int 42

note strings: finally, delimiters that don't suck
	tired of escaping quotes? 67lang's flexible string delimiters are about to blow your mind.

local my_string
	string "hello world"

note here's where it gets interesting - any character can be your delimiter!
	need quotes inside your string? pick a different delimiter:

local my_scary_string
	string !error!
local my_string_with_quotes
	string .hello "world".

note this solves the eternal "quote escaping hell" problem once and for all.
	the first character you use becomes your delimiter. genius? we think so.

note multiline strings that respect your sanity
	sometimes you need more than one line. 67lang makes it beautiful:

local multiline_text
	string
		this is a multiline string
		each indented line becomes part of the string
		joined with newlines

print
	a multiline_text

note collections: dictionaries and lists, no ceremony required
	need a place to store stuff? here you go:

local my_true
	true
local my_false  
	false
local my_dict
	dict
local my_list
	list

print
	a my_true
print
	a my_false

note chapter 2: variables and the philosophy of explicit access
	in 67lang, we believe reading code should be like reading english.
	when you want a variable's value, you ask for it explicitly.

local name
	string "alice"

note the 'a', 'an', and 'access' keywords make variable access crystal clear
	no more wondering "is this a function call or a variable?" you KNOW it's a variable.

local greeting
	concat
		string "hello "
		a name

note output that just works
	printing to the screen should be effortless:

print
	string "this will be"
	string "concatenated with spaces i think"
	string "as it is just an alias for Deno console.log"

print
	a my_scary_string

print
	a my_string_with_quotes

print
	string "new year's "
	string level

print
	a greeting

note chapter 3: making decisions like a human being
	conditionals in 67lang read like natural language. no weird syntax to memorize.

if
	eq
		a my_number
		int 42
then
	print
		string "number is 42"
else
	print
		string "number is not 42"

note chapter 4: loops that loop the way loops should
	iteration is fundamental to programming. 67lang makes it obvious and correct.

local numbers
	list
		int 1
		int 2
		int 3

for num in
	a numbers
do
	print
		a num

note the magic word 'do' isn't just syntax - it's a contract
	"for each item in this collection, DO the following actions"
	it guides your thinking toward correct loop construction.

note chapter 5: data structures that don't fight you
	working with dictionaries and lists should feel natural, not like advanced calculus.

local person
	dict

note setting values uses the beautiful 'where' syntax
	instead of ugly bracket notation, you describe what you're doing in english:

a person key
	where key is
		string "name"
	string "bob"

note the syntax is flexible - use whatever reads best for your situation:

a person data_we_would_like_to_store
	where data_we_would_like_to_store is
		string "age"
	int 30

note getting values back uses the same clear pattern:

print
	a person key
		where key is
			string "name"

print
	a person data_we_would_like_to_store
		where data_we_would_like_to_store is
			string "age"

note chapter 6: string manipulation that doesn't make you cry
	strings are everywhere in real programming. 67lang treats them as first-class citizens.

local text
	string "hello world"

note splitting strings - as simple as it should be:

local words
	a text split
		string " "

print
	a words

note joining them back together:

local rejoined
	a words join
		string "-"

print
	a rejoined

note regex support for when you need the big guns:

local input_with_spaces
	string "a  b   c"
local regex_words
	a input_with_spaces split
		regex /\s+/

print
	a regex_words

note method chaining: watch this beautiful pipeline in action

local word
	string "hello"
local key
	a word split sort join
		where split takes
			string ""
		where join takes
			string ""

print
	a key

note the 'where X takes Y' syntax eliminates ambiguity about which argument goes where.
	method chaining becomes readable, maintainable, and actually pleasant to work with.

note chapter 7: functions that do what they say
	67lang's built-in functions have names that make sense. revolutionary concept, right?

note comparisons that handle multiple values naturally:

print
	eq
		int 5
		int 5

print
	asc
		int 3
		int 5

note arithmetic without the ceremony:

print
	add
		int 10
		int 5
print
	mod
		int 10
		int 3

note logical operations with names that read like english:

print
	all
		true
		false

print
	any
		true
		false

print
	none
		false

note 'all' means all conditions must be true
	'any' means at least one condition must be true
	'none' means no conditions should be true
	your code becomes self-documenting!

note chapter 8: optional type safety (because bugs are the enemy)
	when you want the compiler to watch your back, just add type annotations.
	when you don't need them, skip them. your choice, always.

local typed_number
	type int
	int 42

local typed_string
	type str
	string "hello"

# accessing typed variables
local another_number
	type int
	a typed_number

note type checking enforces type compatibility:
	the following demonstrates errors that the type checker will catch

must_compile_error FIELD_TYPE_MISMATCH=291
	local bad_assignment
		type str  
		a typed_number

# another common error: omitting the do block in loops
must_compile_error EXPECTED_DO_AFTER=297
	for num in
		a numbers
	print
		a num

print 
	a typed_number
print
	a typed_string

note the unusual and unexpected: identifier flexibility
	here's something delightfully surprising about 67lang. you might think that
	identifiers must follow the usual rules (letters, underscore, alphanumerics)
	but 67lang is more flexible than expected!

# TODO: investigate and document unusual identifier support
# local ...
#	string "ellipsis identifier"
# local 0.00$_for_67.8%
#	string "numbers and symbols" 
# 
# these unusual identifiers actually compile (converted to valid JavaScript)
# but currently have runtime execution issues that need fixing.
# the language accepts almost any identifier and mangles it for JS compatibility!

note design philosophy: getting out of your way
	every feature in 67lang exists for a reason: making code readable,
	maintainable, and pleasant to work with. the syntax is minimal because
	our parser is under 100 lines of Python - yet the language is powerful
	enough for real work.
	
	semantic indentation guides your thinking. explicit variable access
	eliminates confusion. flexible string delimiters solve real problems.
	optional type checking catches bugs when you want it to.
	
	67lang doesn't try to be clever - it just gets out of your way so you
	can focus on solving actual problems. welcome to the language that 
	prioritizes human needs over academic theories.

note the approximate JS that it compiles to:
	let typed_number = 42;
	let typed_string = "hello";
	let another_number = typed_number;
	console.log(typed_number);
	console.log(typed_string);