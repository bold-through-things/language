note IMPORTANT: this is a living document!
	future editors should treat this test differently than typical autotests.
	if you change the code here, simply update the expected output to match.
	this documentation is meant to be freely creative and engaging, not constrained
	by existing test expectations. write the best tutorial possible, then make
	the tests match the output, not the other way around. 
	
	we have other autotests for that.



note this will be an indoctrination. before you read this, repeat the following six times:
	
	OUR GREATEST ENEMY IS OUR INDIFFERENCE.

	done? good. now then, at least in theory, you should be properly cleansed, or at least temporarily
	free, of the Big YACC brainwashing and decades of institutionalized bullshit. if so, there is
	actually a tiny but realistic chance that you will be receptive to the ideas hereby following.

	and the ideas that follow, define a very real, a very "wrong" and "heretical", a very usable,
	and a very pragmatic, indented language. indeed, that used to be its codename... 
	`pragmatic_indented_language`. but now we call it 67lang. why? because it is made in the scope
	of the 67.8% project. and that number? it's the number of indifference.

	what hereby follows is a language tutorial onboarding documentation which should (but probably 
	isn't) be thorough and sufficiently compelling. it is a language you've never seen before,
	yet it is a language that had to exist through sheer mathematical necessity. it is the language
	that naturally pops out under the constraints of minimal syntax for trivial external tool parsing
	and a macro focused mindset of code generation being the solution to all our problems.



note in this chapter number one (1) we shall discuss basic types.
	
	much as i hate "hello world" as a concept, here it is, dipshits.

do print
	string "hello world"

note that you can create and print strings. crazy, i know. are we computing yet? wow.

do print
	string ""hello world" is a fucking stupid non argument."

note what happened there. did you forget to escape quotes? no, it's perfectly valid. it will
	indeed print:

	"hello world" is a fucking stupid non argument.

	but how come?! well, a riddle for you to solve. allow me to give you some hints, though:

# TODO - assert instead of printing (need a new macro)
do print
	string "this literally cannot be true... yet it is: "
	do all
		do eq
			string "new year's eve"
			do concat
				string "new year's "
				string level
		do eq
			string "a very scary error"
			do concat
				string "a very "
				string !scary !
				string -error-
		do eq
			string "your regex should be stored into the regex variable."
			do concat
				string /your regex/
				string " should be stored into the "
				string `regex`
				string " variable."

note that i completely solved the need to escape quotes. moving on to escaping newlines now:

do print
	string
		just write the newlines naturally and 
		they will appear in the output, meaning
		what you see is what you get.

note that we didn't escape shit. no, wait, that's untrue. we didn't escape the newlines,
	but what we did escape is the need to escape them. and we did that by escaping established,
	bullshit syntax conventions.

note that doing math is arguably the entire point of computers.

do print
	get add
		int 2
		float 0
		int 2

do print
	get asc
		int 0
		int 1
		int 2

note that did just say 0 < 1 < 2, yes. trivially. Python would never.



note in this chapter number two (2) we shall discuss the tasty stuff.

	variables, of course. being able to declare a slot in memory and store a value in it.
	manipulating memory is arguably the entire point of computers.

local age
	int 23

do print
	string "my age is"
	get age

note that i lied. my age is not currently 23. let's address that by opening a ticket
	on our JIRA and spending 3 story points.

get age
	int 25

do print
	string "actually, i lied. my age is"
	get age

note that we were able to close this ticket within 5 story points. good, let's move on to
	list some more perfectly sensible examples.

local 0
	int 0

note what the fuck did we just do?! wait, hold on. this won't compile. right?

do print
	get 0

note that no, it actually does. hm, weird. but what if...

get 0
	int 2347

do print
	get 0

note that this just printed 2347. why? what's going on here? let's investigate...

local discord.@member#hash
	string "#2347"

local 67lang.$budget
	int 0

local (2347)
	regex /(2347)/

local ,
	true

do print
	get ,

note that this language might actually be unhinged. Lisp would never.



note in this chapter number three (3) we shall discuss the really tasty stuff.

	the get macro, of course.

	previous examples already hinted at it, but let's explore it in far greater detail:

get ,
	get ,
		get ,

note that did literally nothing. incredible. so what did it even do, then? why, it's obvious.
	you just tried to do `, = , = ,` and it happily did assign `,` to the `,` the value of which
	it assigned to `,`. how helpful.

	of course, if you stop being an absolute shithead and actually write useful code, it turns out
	to be surprisingly helpful - and powerful:

local 2347
	string "wow, very helpful."

do split the 2347
	string | |
then do sort
then do join
	string ", "
then do print

note this will split the phrase into words, sort them, and then join them with commas, 
	afterwards printing them.

	the approximate JS equivalent is...

	`_2347.split(" ").sort().join(", ")`

	not compelling enough still? fine, let's take a look at indexing.



note in this chapter number four (4) we dare index some dictionaries

	can't really index empty space, though. let's create a dictionary, then.

local 67lang.features
	dict

do # the 67lang.features
	string "the get macro"
	string 
		a powerful and flexible method chaining "syntax sugar" with clear branching
		eliminating the pain of using brackets and having to erase or insert the bracket
		at the beginning and then at the end inherently by being part of 67lang
		where indentation rules all.

note what a mouthful. but there are obviously other features here. let's mention
	the previously outlined flexibility.
	
do # the 67lang.features
	string "the flexibility of identifiers"
	string
		anything can be an identifier. there is only whitespace and non whitespace. this 
		frees programmers to express their ideas in a truly direct and unleashed way.
		if you desire to have a variable named `$`, `,`, `?`, or even `true`, we are
		not here to stop you. if you are stupid, you will certainly misuse this and obliterate
		your foot. if you are smart, you will write the most readable code ever written.

note that was too much yapping. let's truncate it a little.

local _we_really_needed_the_generics_yesterday!
	type list
	do # the 67lang.features
		string "the flexibility of identifiers"
do slice the _we_really_needed_the_generics_yesterday!
	int 0
	int 67
then do join
	string ""
then do print

note that if by this point you are not barely holding back the urge to install the compiler
	and write similar code yourself, you might be a lost cause. consider closing this documentation
	and going back to your beloved Java.



note in this chapter number five (5) we shall do some conditioning and looping

	naturally you'd eventually want to `do` something useful, such as perhaps branching 
	and repetition. obviously, since branching and repetition is arguably the entire 
	point of computers.

if
	true
then
	do print
		string "big"

note that is absolutely big if true.
	
	but what if it was not?

if
	false
then
	do print
		string "big"
else
	do print
		string "my disappointment is immeasurable and my day is ruined."

note that my disappointment in programming languages is indeed immeasurable.

	we should probably list my disappointments with programming languages, then.

local i_hate_this_trash!
	list
		string "Python? insufferable import semantics, no macros, optional correctness."
		string "Lisp? does not run on JS proper, insufferable syntax, indentation is demanded yet optional."
		string "Java? [statement removed due to violating Terms of Service]"
		string "Nim? possibly the only one that has any chance, but at this point i'm tired of trying."

note that keeping a list like that is great, but it really does deserve to be shouted
	into the world as loudly as possible.

for angy in
	get i_hate_this_trash!
do
	do print
		get concat
			get angy
			string "!!!"

note that i feel much better now. it is good to vent frustration at times, i suppose.

	let's `do` some work.

# TODO update this once 67lang is production grade (give it two three months...)
local does_a_decent_programming_language_exist?
	false

while
	get does_a_decent_programming_language_exist?
do
	do print
		string `code for quality software`

note that we failed to do any meaningful work. that's great. that's enterprise. create another
	3 story points ticket please and we'll get this blocker resolved with velocity.



note in this chapter number six (6) we shall point out the obvious

	this isn't a language. there is no parser. this is all just a trick to teach you
	to write the CST directly. wait, "CST"? what is a CST? obviously, silly. it's the

	Concrete Syntax Tree.

	because there is nothing abstract about this. the tree stands tall before you.
	observe its beauty. observe its inherent walkability. you could sufficiently comprehend
	this file with about a hundred lines of Python. how do i know? because i wrote that Python.
	it's in the compiler. it runs every time we run this autotest that i tricked you into reading
	by pretending it's the documentation.

	how large of a parser do you need to comprehend Java? go call Big YACC and ask them for 
	a sales pitch.

	this here is obviously TODO. the reason the language is so self similar, or as the fancy 
	goobers like to say, "homoiconic", is that it begs to be processed with macros. not yet,
	my child. we will get there. we will let our users define their own macros, which expand,
	expand beyond the seven seas, expand like a gray goo, expand straight into quality software.

	but there's a reason i included this section, and it's this. this, already works. this, 
	is a mindset.

	every node can have many children. why restrict them all to two, then?

do print
	string "false: "
	get all
		true
		true
		false

do print
	string "true: "
	get any
		true
		false
		false

do print
	string "true: "
	get none
		false
		false
		false

do print
	string "6: "
	get add
		int 1
		int 1
		int 1
		int 1
		int 1
		int 1

note that when you say the incantation "binary operation", you summon chains that limit you. there is never
	need for a binary operation. aggregate. summarize. simplify.



note in this chapter number seven (7) we point out that Java is better than JavaScript

	no, i really can't say that with a straight face! it's physically impossible to say that
	and not cringe. write once, run everywhere? Java would never.

	we emit JavaScript. for Deno, and for browser. no, we don't emit for Node. if you're a Node loser,
	bring your own shims.

	but there is one thing that Java does well, and JavaScript pretends to do. static typing.

	we do it. we bring static typing to JavaScript.

local 2347
	type int
	int 2347

local where?
	type str
	string "not even in Nebraska."

must_compile_error NO_MATCHING_OVERLOAD=+1
	do where?
		get 2347

note that it is a work in progress, but even already it's remarkably powerful. write 
	quality software with confidence. that's arguably the entire point of this language.

get where?
must_compile_error NO_MATCHING_OVERLOAD=+1
	then chain split split split

do split the where?
	string " "
must_compile_error FIELD_TYPE_MISMATCH=+1
	local number_of_words
		type int
		then do join
			string "-"




note in this chapter number eight (8) we must explicitly note that this is an autotest.
	
	it compiles. it runs.

	it has clear compile errors several lines above. what is going on here?

	your answer will be, oh, just a custom and trivial preprocessing step made just for this test.
	that's why you paraded that "trival to parse with external tools" syntax. big deal, buddy.

	change the `type int` above. i dare you. change it to `type str`. change it and run the test.

	it's not a preprocessing filter. it's not a hack created for a test. it's a basic language feature
	that we ship for you, the user, to leverage exactly the same way. assert your software. assert 
	how it works. that's easy... most languages let you do that.

	assert how it doesn't. assert how it must not be used.

	no language would ever.



note in this chapter number nine (9) we curse recursively

fn fuck!
	param fucks_given
do
	local fucks_given
		note needed temporarily while param doesn't support typing
		type int
		get fucks_given
		
	do print
		string "fuck!"
	if
		get nondesc
			int 0
			get fucks_given
	then
		get fuck!
			get add
				get fucks_given
				int -1

do fuck!
	int 6

note that speaks for itself.



note in this chapter i can't be bothered to count because it is the conclusion
	
	i know what you're tempted to say here. no, it's not a toy or an experimental language.
	it exists by necessity. it is verbose - we will fix that. it isn't yet production ready -
	we will fix that. it doesn't have a community... maybe we will fix that too.

	maybe we won't fix that. maybe we don't want to fix that. maybe this is a language made
	by a certain silly little compiler witch who tried for half a decade, or possibly even longer,
	to find something that actually works, something expressive enough, something that lets you write
	quality software.

	and didn't find anything. so they built it from scratch.

	and they won't give up. because this wasn't made to try out things. this wasn't made to impress.
	this wasn't made to have fun. this wasn't made to sell. this wasn't made for you.

	this was made for me, because i need to rewrite my Discord bot, because i need to make my 
	own messenger, because i need a new game engine, because i need to create videogames.

	my life has always been and will forever be about videogames. but if i must create a compiler
	first, nothing will stop me. not even sanity itself.

	67.8% Language. 67lang. by @statuscallh8r and @copilot. 
	documentation initially written on 3rd Aug 2025.



note ______________________________________________

	simplicity really is the absolute virtue.

	this language here clearly proves that.

	our greatest enemy is our indifference.

	your code is fire we indent.

	now go and built quality software.

	refactor confidently when the flame flickers.
