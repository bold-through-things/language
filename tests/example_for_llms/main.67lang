note this file here is intended as a crash course into the 67lang
	syntax and semantics. it leverages a correlational approach,
	showcasing the very familiar JS and its translation into our
	language.



note 67lang is very strict and quite particular. we will not parse spaces
	as indentation, it will compile error. the indentation is key for our
	structure. if you screw up with it, your code will obviously fail
	to compile in all kinds of unexpected ways. no different from Python,
	in that sense.
	
	just think of it as what it is, a Concrete Syntax Tree. you are just writing
	the code tree by hand. if you do not indent the nodes correctly, you
	won't assign them to the proper parent.



local name
	type str
	string "Alice"

local age
	type int
	int 25

note we prefer snake_case.
local is_active
	true

do print
	get name
	get age
	get is_active

note the above is roughly equivalent to following JS
	
	let name = "Alice";
	const age = 25;
	var isActive = true;
	console.log(name, age, isActive);



note here is a **key** idea. here in our realm, you must
	remember one thing only. here **everything** is functions.
	**even the fields. even the locals too!**

	so now, to name the Alice yet again, you simply do...

do name
	string "Aris"

do print
	get name

note the above is roughly equivalent to following JS

	name = "Aris";
	console.log(name);

note why then an assignment there? it's simple, **all in arity.**
	each `local` makes two """functions""" visible. they technically
	behave a little differently (think scopes) but generally you use
	them the same way as any other function.

	so `local name` simply created...
	
	- a `name()` getter
	- a `name(value)` setter

	and now to prove that they are functions, let's change up all the words
	a little.

get print
	do name

note that still works. how come?! the `do` and `get` are aliases.
	why would they not be?! it's all functions. you as the user know
	much better what's a getter, what's a setter.

	and then again, is this a `do`? or is it `get`?

	do ? the database
		string "SELECT * FROM ..."
	get ? from database
		string "SELECT * FROM ..."



fn greet
	param person
		type str
	returns
		type str
do
	return
		do concat
			string "Hello, "
			get person

do print
	do greet
		string "Alice"

note the above is roughly equivalent to following JS

	function greet(person, dummy_param) {
		return "Hello, " + person;
	}
	console.log("Alice", false);



local numbers
	list
		type int
		int 1
		int 2
		int 3
		int 4
		int 5

do push the numbers
	int 6

do print
	do # the numbers
		int 0
	
do print
	do # the numbers
		do sub
			get length from numbers
			int 1

note the above is roughly equivalent to following JS
	
	let numbers = [1, 2, 3, 4, 5];
	numbers.push(6);
	console.log(numbers[0]);
	console.log(numbers[numbers.length - 1]);



note i commented out this code because
	`type * for V` conundrum is unclear.

	we probably will not support that actually...
	instead i'd rather force the users to know all their dicts
	by heart.

	and that's to say, auto `heap_entry` mapping.
	
	local user
		dict
			type str for K
			type * for V
			entry
				string "employed"
				true
			entry
				string "company"
				string "67.8%"
			entry
				string "address"
				dict
					type str for K
					type str for V
					entry
						string "city"
						string "New York"

	do # the user
		string "name"
		string "Bob"

	do # the user
		string "age"
		int 30

	do # the user
		string "address"
	then do #
		string "oblast"
		string "Donetsk Oblast"

	do print
		get user

note the above is roughly equivalent to following JS
	
	let user = {
		"employed": true,
		"company": "67.8%"
		"address": {
			"city": "New York"
		}
	};

	user["name"] = "Bob"
	user["age"] = 30
	user["address"]["oblast"] = "Donetsk Oblast"
	
	console.log(user);



if
	do nondesc
		int 18
		get age
then
	do print
		string "Adult"
else
	do print
		string "Minor"

note the above is roughly equivalent to following JS

	if (age >= 18) {
		console.log("Adult");
	} else {
		console.log("Minor");
	}



for number in
	get numbers
do
	do print
		get number

note the above is roughly equivalent to following JS
	
	for (let number of numbers) {
		console.log(number);
	}



type Person is heap_entry
	has name
		type str
	has age
		type int

local alice
	do Person
		string "Alice"
		int 30
		
	note this shouldn't be needed, but type checking
		is a work in progress
	type Person

do print
	get name from alice
do print
	get age from alice

do name the alice
	string "Alicia"

do print
	get name from alice

note both are the "name" getter, but it is intelligently
	matched by type. ad hoc polymorphism now saves the day!
do print
	get name

note the above is roughly equivalent to following JS

	function Person(name, age) {
		this.name = name;
		this.age = age;
	}

	let alice = new Person("Alice", 30);
	console.log(alice.name);
	console.log(alice.age);

	alice.name = "Alicia";
	console.log(alice.name);
	console.log(name);



note the pipelining syntax.

	perhaps the greatest thing about this language?
	you can write things imperatively, and still avoid the
	`local` spam.

local 1
	int 1

get 1 as ?
then do add
	get ?
	int 1
then do print

note that just printed 3. indeed, as 1 + 1 is... wait, what even?!

	oh right, we passed things manually and automatically. consider
	what it actually compiled to...

	const _last_0x1 = age;
	const _question = age;
	const _last_0x2 = add(_last_0x1, _question, 10);
	console.log(_last_0x2);

	this is the **key**. the previous computed value becomes the **first** argument.
	that is the `then` semantics. if you omit the `then`...

get 1 as ?
do add
	get ?
	int 1
then do print

note then you get a 2, as you'd expect. or otherwise...

get 1 as ?
then do add
	int 1
then do print

note this prints 2 as well. it is quite flexible. but even better!

local things_to_say
	list
		type str
		string "67lang is awesome"
		string "67lang is flexible as fuck"
		string "67lang is all you ever need"
		string "67lang is on the brink"
		string "67lang is good enough to write a Discord bot"
		string "67lang is almost good enough for everything."

local max_characters
	int 0
local found_word
	string ""

for thing in
	get things_to_say
do
	for word in
		do split the thing
			string " "
	do
		note this is needed temporarily... TODO! bad type inference!
		local word
			type str
			get word
		note this crazy `then` nonsense!
		get length from word
		if
			then get desc
				get max_characters
		then
			note this assigns max_characters!
			then do max_characters
			note `into` to set variables...
			get word into found_word
			note you could also just...
			get found_word from word

do print
	get found_word

note the above is roughly equivalent to following JS

	let things_to_say = [/* a bunch of strings */];
	let max_characters = 0;
	let found_word = "";
	for (let thing of things_to_say) {
		for (let word of thing.split(" ")) {
			if (word.length > max_characters) {
				max_characters = word.length;
				found_word = word;
				found_word = word;
			}
		}
	}
	console.log(found_word);



note also commented out, TODO!
	do print
		string "Bob's city"
		get # from user
			string "address"
		then get #
			string "city"

note no, no, wait! that will not work. it will instead print:

	Bob's city {the entire address object} New York

	you have to be aware of this, my dear. all those pipelining steps do actually
	"return" their values up the tree. instead...

	get # from user
		string "address"
	do print
		string "Bob's city"
		then get #
			string "city"



note that we also have this beast...

get # from things_to_say
	int 0
then do split
	string " "
then chain sort join print
	string " - what words!"

note the `sort join print` is quite contrived. the main use case
	for this is probably to access deeply nested values. but i would
	need to then define several `heap_entry` types and i... can not
	be arsed!

	the syntax is rock simple:

	`then chain step0 step1 step2 ... last_step`

	one thing which we must note is that you can pass arguments...
	but only to the step which is `last_step`. all steps implicitly
	also receive a single argument, which then becomes their firstmost 
	argument. whatever we are piping.



note that, oh yeah, you can now do closures! kind of.

	you can now bind the functions.

fn create_counter
	returns
		type callable
			type int for RV
do
	note you do need a class or dict
		as the bound values are literals.
		the Java problem. we will fix it later.
	note oh good, great, we can't use : in class names.
		bug! TODO!
		and in param names too i guess. TODO!
	type create_counter_store is heap_entry
		has count
			type int
	local _
		get create_counter_store
			int 0
	fn create_counter::count
		param _
			type create_counter_store
		returns
			type int
	do
		do add as new
			get count from _
			int 1
		return
			do count the _
				get new

	return
		bind fn create_counter::count as callable
			get _

local counter
	do create_counter

do print
	string "wow, counting!"

do print
	do toString
		do ~ the counter
	do toString
		do ~ the counter
	do toString
		do ~ the counter
	do toString
		do ~ the counter
	do toString
		do ~ the counter
	do toString
		do ~ the counter

note that is rather tedious and quite verbose! but you should
	celebrate we have it to begin with. we'll get proper closures
	eventually, with JavaScript it's harder not to!



note `bind` is far more flexible...

fn bool_printer
	param value
		type bool
	param if_true
		type str
	param if_false
		type str
	returns
		type void
do
	if
		get value
	then
		do print the if_true
	else
		do print the if_false

local politely_agree
	bind fn bool_printer as callable
		_
		string "i would indeed like to agree."
		_

do ~ the politely_agree
	true
	string "what?! utter BULLSHIT!"

do ~ the politely_agree
	false
	string "what?! utter BULLSHIT!"



note the above is roughly equivalent to following JS
	
	function createCounter() {
		let count = 0;
		return function() {
			return ++count;
		};
	}




note these things aren't supported (yet?)

	// Simple loop
	for (let i = 0; i < 3; i++) {
		console.log(i);
	}

	// Arrow functions and array methods
	const evenNumbers = numbers.filter(n => n % 2 === 0);
	const doubled = numbers.map(n => n * 2);
	const sum = numbers.reduce((acc, n) => acc + n, 0);

	// Object destructuring
	const {name: userName, age: userAge} = user;

	// Template literals
	const message = `User ${userName} is ${userAge} years old`;

	// Default parameters and rest operator
	function createUser(name, age = 18, ...hobbies) {
		return {
			name,
			age,
			hobbies
		};
	}

	// Promises and async operations
	function fetchData(url) {
		return new Promise((resolve, reject) => {
			setTimeout(() => {
				if (url) {
					resolve(`Data from ${url}`);
				} else {
					reject(new Error("No URL provided"));
				}
			}, 1000);
		});
	}

	// Async/await
	async function getData() {
		try {
			const data = await fetchData("https://api.example.com");
			return data;
		} catch (error) {
			console.error("Error:", error.message);
			return null;
		}
	}

	// Classes with inheritance
	class Animal {
		constructor(name) {
			this.name = name;
		}
		
		speak() {
			return `${this.name} makes a sound`;
		}
	}

	class Dog extends Animal {
		constructor(name, breed) {
			super(name);
			this.breed = breed;
		}
		
		speak() {
			return `${this.name} barks`;
		}
		
		static getBestFriend() {
			return "Human";
		}
	}

	// Closures and higher-order functions
	function createCounter() {
		let count = 0;
		return function() {
			return ++count;
		};
	}

	const counter = createCounter();

	// Function composition
	const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);
	const addOne = x => x + 1;
	const multiplyByTwo = x => x * 2;
	const square = x => x * x;

	const complexOperation = pipe(addOne, multiplyByTwo, square);

	// Proxies for meta-programming
	const observableObject = new Proxy({}, {
		set(target, property, value) {
			console.log(`Setting ${property} to ${value}`);
			target[property] = value;
			return true;
		},
		get(target, property) {
			console.log(`Getting ${property}`);
			return target[property];
		}
	});

	// Generators
	function* fibonacci(limit) {
		let a = 0, b = 1;
		while (a < limit) {
			yield a;
			[a, b] = [b, a + b];
		}
	}

	// Symbol usage for private-like properties
	const _private = Symbol('private');
	class SecureClass {
		constructor(value) {
			this[_private] = value;
		}
		
		getValue() {
			return this[_private];
		}
	}

	// Advanced async patterns - concurrent execution
	async function processMultipleRequests(urls) {
		const promises = urls.map(url => fetchData(url));
		const results = await Promise.allSettled(promises);
		
		return results.map((result, index) => ({
			url: urls[index],
			status: result.status,
			data: result.status === 'fulfilled' ? result.value : null,
			error: result.status === 'rejected' ? result.reason.message : null
		}));
	}

	// WeakMap for memory-efficient associations
	const privateData = new WeakMap();
	class DataContainer {
		constructor(data) {
			privateData.set(this, data);
		}
		
		getData() {
			return privateData.get(this);
		}
	}

	// Custom error handling
	class ValidationError extends Error {
		constructor(message, field) {
			super(message);
			this.name = 'ValidationError';
			this.field = field;
		}
	}

	// Decorator pattern (experimental)
	function measureTime(target, propertyKey, descriptor) {
		const originalMethod = descriptor.value;
		descriptor.value = function(...args) {
			const start = performance.now();
			const result = originalMethod.apply(this, args);
			const end = performance.now();
			console.log(`${propertyKey} took ${end - start} milliseconds`);
			return result;
		};
		return descriptor;
	}

	// Usage examples
	const dog = new Dog("Rex", "Golden Retriever");
	const fibSeq = [...fibonacci(100)];
	observableObject.test = "value";
	const result = complexOperation(5); // ((5 + 1) * 2)^2 = 144


