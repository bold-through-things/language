67lang:file
	note 
		String
	note
		str
	note TODO
		fn str is PrototypeCall
			sync
			constructor Number
			fn toString
			param self
				type int
			returns
				type str
	note TODO
		fn str is PrototypeCall
			sync
			constructor Object
			fn toString
			param self
				type *
			returns
				type str
	note
		int
	note
		dict
	note 
		Array
	note 
		WebSocket
	note 
		URL
	note 
		TextEncoder
	note 
		TextDecoder
	note
		Base64
	note
		fetch
	note
		JSON
	note 
		event loop
	note TODO this isn't valid (int...)
	note
		67lang builtins
	note TODO because varargs we can't express this yet. `inside` for now hardcoded in compiler
	note TODO should only show this if we target Deno

67lang:file
	local input
		67lang:pipeline_result
			67lang:call stdin
	local words
		67lang:pipeline_result
			67lang:call split
				67lang:call input
				string "\n"
	local groups
		dict
			type str for K
			type list for V
				type str
	do
		local _0x43_for_word__index
			int 0
		local _0x44_for_word__list
			67lang:pipeline_result
				67lang:call words
		while
			67lang:pipeline_result
				67lang:call asc
					67lang:pipeline_result
						67lang:call _0x43_for_word__index
					67lang:pipeline_result
						67lang:call length
							67lang:call _0x44_for_word__list
			do
				local word
					67lang:pipeline_result
						67lang:call #
							67lang:call _0x44_for_word__list
							67lang:pipeline_result
								67lang:call _0x43_for_word__index
				67lang:pipeline_result
					67lang:call _0x43_for_word__index
						67lang:pipeline_result
							67lang:call add
								67lang:call _0x43_for_word__index
								int 1
				67lang:pipeline_result
					67lang:call split
						67lang:call word
						string ""
				67lang:pipeline_result
					67lang:call sort
						67lang:get_last_pipeline_result
				local key
					67lang:get_last_pipeline_result
				67lang:pipeline_result
					67lang:call join
						67lang:get_last_pipeline_result
						string ""
				# TODO this really ought to be a macro. with(a groups key)do(if(self eq null)then(self(list))) or something?
				#  well, that is still too verbose. perhaps something more like a groups key (executing if (self eq null); list)
				#  which would be hilariously similar to a Python comprehension. lmfao. WHAT THE FUCK AM I COOKING ?!
				if
					67lang:pipeline_result
						67lang:call none
							67lang:pipeline_result
								67lang:call has_keys
									67lang:call groups
									67lang:pipeline_result
										67lang:call key
					then
						67lang:pipeline_result
							67lang:call #
								67lang:pipeline_result
									67lang:call groups
								67lang:pipeline_result
									67lang:call key
								list
									type str
				67lang:pipeline_result
					67lang:call #
						67lang:pipeline_result
							67lang:call groups
						67lang:pipeline_result
							67lang:call key
				67lang:pipeline_result
					67lang:call push
						67lang:get_last_pipeline_result
						67lang:pipeline_result
							67lang:call word
	do
		local _0x48_for_group__index
			int 0
		local _0x49_for_group__list
			67lang:pipeline_result
				67lang:call values
					67lang:call groups
		while
			67lang:pipeline_result
				67lang:call asc
					67lang:pipeline_result
						67lang:call _0x48_for_group__index
					67lang:pipeline_result
						67lang:call length
							67lang:call _0x49_for_group__list
			do
				local group
					67lang:pipeline_result
						67lang:call #
							67lang:call _0x49_for_group__list
							67lang:pipeline_result
								67lang:call _0x48_for_group__index
				67lang:pipeline_result
					67lang:call _0x48_for_group__index
						67lang:pipeline_result
							67lang:call add
								67lang:call _0x48_for_group__index
								int 1
				67lang:pipeline_result
					67lang:call print
						67lang:pipeline_result
							67lang:call join
								67lang:pipeline_result
									67lang:call group
								string " "

