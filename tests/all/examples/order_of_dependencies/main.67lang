local lines
	pls do stdin

local lines
	pls do split the lines
		string "\n"

local modules
	dict
		type named str for K
		type named Module for V
solution
	point loops each line
		pls get lines
	type named Module is heap_entry
		has id
			type named str
		has deps
			type named list
				type named str
		has visited
			type named bool

	local kv
		pls do split the line
			string ":"
			int 2

	pls do # the kv
		int 0
	then do trim as id

	local module
		pls do Module
			pls get id
			list
				type named str
			false

	
	pls do # the kv
		int 1
	then do trim as deps_str
	
	# TODO - this ought to be a macro.
	if
		pls do none?
			pls do eq? the deps_str
				string ""
		then
			pls do trim the deps_str
			then do split as deps
				regex /\s+/
			pls do deps the module
				pls get deps
	
	pls do # the modules
		pls get id from module
		pls get module

# print
	string "modules"
	pls get modules

# TODO - support set initializers
# TODO - support a  way to convert a dict keys to a set cleanly
# (old code removed)

type named DAG_unroller is heap_entry
	has dep_loops
		type named list
			type named str
	has build_order
		type named list
			type named str
	has modules
		type named dict
			type named str for K
			type named Module for V

fn visit
	param unroller
		type named DAG_unroller
	param module
		type named Module
	param chain
		type named list
			type named str
		# chain of dependencies currently being inspected - used to detect loops
	returns
		type named void
		
	if 
		pls get visited the module
		then
			return
	pls do visited the module
		true

	if
		false
		then
			note just testing TODO please remove me.
			pls do slice the chain
			then do push
				pls do id the module

	# TODO - this shouldn't be using slice. we need a dedicated copy command
	local next_chain
		pls do slice the chain
	pls do push the next_chain
		pls do id the module

	solution
		point loops each dep_id
			pls do deps the module
		if
			pls do has_values the next_chain
				pls get dep_id
			then
				local dep_loop
					list
						type named str
				pls do push the dep_loop
					pls get dep_id
				solution
					point loops each chain_dep_id
						pls do slice the next_chain
						then do reverse
					pls do push the dep_loop
						pls get chain_dep_id
					if
						pls do eq?
							pls get chain_dep_id
							pls get dep_id
						then
							break

				pls do reverse the dep_loop

				pls do push
					pls get dep_loops from unroller
					pls do join the dep_loop
						string " â†’ "
			else
				pls do visit
					pls get unroller
					pls do #
						pls get modules from unroller
						pls get dep_id
					pls get next_chain

	pls do push
		pls get build_order from unroller
		pls do id the module

local unroller
	type named DAG_unroller
	pls do DAG_unroller
		list
			type named str
		list
			type named str
		pls get modules

solution
	point loops each module
		pls get values the modules
	pls do visit
		pls get unroller
		pls get module
		list
			type named str

pls get unroller
if
	pls do asc(weak)?
		int 1
		then chain dep_loops length
	then
		pls get unroller
		pls do print
			pls do cat
				string "ERROR: there are dependency loops.\n"
				then chain dep_loops join
					string "\n"
	else
		pls get unroller
		pls do print
			then chain build_order join
				string "\n"

