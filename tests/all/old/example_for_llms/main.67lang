note this file here is intended as a crash course into the 67lang
	syntax and semantics. it leverages a correlational approach,
	showcasing the very familiar JS and its translation into our
	language.



note 67lang is very strict and quite particular. we will not parse spaces
	as indentation, it will compile error. the indentation is key for our
	structure. if you screw up with it, your code will obviously fail
	to compile in all kinds of unexpected ways. no different from Python,
	in that sense.
	
	just think of it as what it is, a Concrete Syntax Tree. you are just writing
	the code tree by hand. if you do not indent the nodes correctly, you
	won't assign them to the proper parent.



local name
	type named str
	string "Alice"

local age
	type named int
	int 25

note we prefer snake_case.
local is_active
	true

pls do print
	pls get name
	pls get age
	pls get is_active

note the above is roughly equivalent to following JS
	
	let name = "Alice";
	const age = 25;
	var isActive = true;
	console.log(name, age, isActive);



note here is a **key** idea. here in our realm, you must
	remember one thing only. here **everything** is functions.
	**even the fields. even the locals too!**

	so now, to name the Alice yet again, you simply do...

pls do name
	string "Aris"

pls do print
	pls get name

note the above is roughly equivalent to following JS

	name = "Aris";
	console.log(name);

note why then an assignment there? it's simple, **all in arity.**
	each `local` makes two """functions""" visible. they technically
	behave a little differently (think scopes) but generally you use
	them the same way as any other function.

	so `local name` simply created...
	
	- a `name()` getter
	- a `name(value)` setter

	and now to prove that they are functions, let's change up all the words
	a little.

pls get print
	pls do name

note that still works. how come?! the `do` and `get` are aliases.
	why would they not be?! it's all functions. you as the user know
	much better what's a getter, what's a setter.

	and then again, is this a `do`? or is it `get`?

	pls do ? the database
		string "SELECT * FROM ..."
	pls get ? from database
		string "SELECT * FROM ..."



fn greet
	param person
		type named str
	returns
		type named str
	return
		pls do cat
			string "Hello, "
			pls get person

pls do print
	pls do greet
		string "Alice"

note the above is roughly equivalent to following JS

	function greet(person, dummy_param) {
		return "Hello, " + person;
	}
	console.log("Alice", false);



local numbers
	list
		type named int
		int 1
		int 2
		int 3
		int 4
		int 5

pls do push the numbers
	int 6

pls do print
	pls do # the numbers
		int 0
	
pls do print
	pls do # the numbers
		pls do sub
			pls get length from numbers
			int 1

note the above is roughly equivalent to following JS
	
	let numbers = [1, 2, 3, 4, 5];
	numbers.push(6);
	console.log(numbers[0]);
	console.log(numbers[numbers.length - 1]);



note i commented out this code because
	`type named unknown for V` conundrum is unclear.

	we probably will not support that actually...
	instead i'd rather force the users to know all their dicts
	by heart.

	and that's to say, auto `heap_entry` mapping.
	
	local user
		dict
			type named str for K
			type named unknown for V
			entry
				string "employed"
				true
			entry
				string "company"
				string "67.8%"
			entry
				string "address"
				dict
					type named str for K
					type named str for V
					entry
						string "city"
						string "New York"

	pls do # the user
		string "name"
		string "Bob"

	pls do # the user
		string "age"
		int 30

	pls do # the user
		string "address"
	then do #
		string "oblast"
		string "Donetsk Oblast"

	pls do print
		pls get user

note the above is roughly equivalent to following JS
	
	let user = {
		"employed": true,
		"company": "67.8%"
		"address": {
			"city": "New York"
		}
	};

	user["name"] = "Bob"
	user["age"] = 30
	user["address"]["oblast"] = "Donetsk Oblast"
	
	console.log(user);



if
	pls do asc(weak)?
		int 18
		pls get age
	then
		pls do print
			string "Adult"
	else
		pls do print
			string "Minor"

note the above is roughly equivalent to following JS

	if (age >= 18) {
		console.log("Adult");
	} else {
		console.log("Minor");
	}



solution
	point loops each number
		pls get numbers
	pls do print
		pls get number

note the above is roughly equivalent to following JS
	
	for (let number of numbers) {
		console.log(number);
	}



type named Person is heap_entry
	has name
		type named str
	has age
		type named int

local alice
	pls do Person
		string "Alice"
		int 30
		
	note this shouldn't be needed, but type named checking
		is a work in progress
	type named Person

pls do print
	pls get name from alice
pls do print
	pls get age from alice

pls do name the alice
	string "Alicia"

pls do print
	pls get name from alice

note both are the "name" getter, but it is intelligently
	matched by type. ad hoc polymorphism now saves the day!
pls do print
	pls get name

note the above is roughly equivalent to following JS

	function Person(name, age) {
		this.name = name;
		this.age = age;
	}

	let alice = new Person("Alice", 30);
	console.log(alice.name);
	console.log(alice.age);

	alice.name = "Alicia";
	console.log(alice.name);
	console.log(name);



note the pipelining syntax.

	perhaps the greatest thing about this language?
	you can write things imperatively, and still avoid the
	`local` spam.

local 1
	int 1

pls get 1 as ?
then do sum
	pls get ?
	int 1
then do print

note that just printed 3. indeed, as 1 + 1 is... wait, what even?!

	oh right, we passed things manually and automatically. consider
	what it actually compiled to...

	const _last_0x1 = age;
	const _question = age;
	const _last_0x2 = sum(_last_0x1, _question, 10);
	console.log(_last_0x2);

	this is the **key**. the previous computed value becomes the **first** argument.
	that is the `then` semantics. if you omit the `then`...

pls get 1 as ?
pls do sum
	pls get ?
	int 1
then do print

note then you get a 2, as you'd expect. or otherwise...

pls get 1 as ?
then do sum
	int 1
then do print

note this prints 2 as well. it is quite flexible. but even better!

local things_to_say
	list
		type named str
		string "67lang is awesome"
		string "67lang is flexible as fuck"
		string "67lang is all you ever need"
		string "67lang is on the brink"
		string "67lang is good enough to write a Discord bot"
		string "67lang is almost good enough for everything."

local max_characters
	int 0
local found_word
	string ""

solution
	point loops each thing
		pls get things_to_say
	solution
		point loops each word
			pls do split the thing
				string " "
		note this is needed temporarily... TODO! bad type named inference!
		local word
			type named str
			pls get word
		note this crazy `then` nonsense!
		pls get length from word
		if
			then get desc?
				pls get max_characters
			then
				pls get length from word
				note this assigns max_characters!
				then do max_characters
				note `into` to set variables...
				pls get word into found_word
				note you could also just...
				pls get found_word from word

pls do print
	pls get found_word

note the above is roughly equivalent to following JS

	let things_to_say = [/* a bunch of strings */];
	let max_characters = 0;
	let found_word = "";
	for (let thing of things_to_say) {
		for (let word of thing.split(" ")) {
			if (word.length > max_characters) {
				max_characters = word.length;
				found_word = word;
				found_word = word;
			}
		}
	}
	console.log(found_word);



note also commented out, TODO!
	pls do print
		string "Bob's city"
		pls get # from user
			string "address"
		then get #
			string "city"

note no, no, wait! that will not work. it will instead print:

	Bob's city {the entire address object} New York

	you have to be aware of this, my dear. all those pipelining steps do actually
	"return" their values up the tree. instead...

	pls get # from user
		string "address"
	pls do print
		string "Bob's city"
		then get #
			string "city"



note that we also have this beast...

pls get # from things_to_say
	int 0
then do split
	string " "
then chain sort join print
	string " - what words!"

note the `sort join print` is quite contrived. the main use case
	for this is probably to access deeply nested values. but i would
	need to then define several `heap_entry` types and i... can not
	be arsed!

	the syntax is rock simple:

	`then chain step0 step1 step2 ... last_step`

	one thing which we must note is that you can pass arguments...
	but only to the step which is `last_step`. all steps implicitly
	also receive a single argument, which then becomes their firstmost 
	argument. whatever we are piping.



note that, oh yeah, you can now do closures! kind of.

	you can now bind the functions.

fn create_counter
	returns
		type named callable0
			type named int for RV
	note what the fuck why does this *need* a `yo`?! TODO
	yo
		note you do need a class or dict
			as the bound values are literals.
			the Java problem. we will fix it later.
		note oh good, great, we can't use : in class names.
			bug! TODO!
			and in param names too i guess. TODO!
		type named create_counter_store is heap_entry
			has count
				type named int
		local _
			pls get create_counter_store
				int 0
		fn create_counter::count
			param _
				type named create_counter_store
			returns
				type named int
			yo
				pls do sum as new
					pls get count from _
					int 1
				return
					pls do count the _
						pls get new

		return
			bind fn create_counter::count as callable
				pls get _

local counter
	pls do create_counter

pls do print
	string "wow, counting!"

pls do print
	pls do str
		pls do ~ the counter
	pls do str
		pls do ~ the counter
	pls do str
		pls do ~ the counter
	pls do str
		pls do ~ the counter
	pls do str
		pls do ~ the counter
	pls do str
		pls do ~ the counter

note that is rather tedious and quite verbose! but you should
	celebrate we have it to begin with. we'll get proper closures
	eventually, with JavaScript it's harder not to!



note `bind` is far more flexible...

fn bool_printer
	param value
		type named bool
	param if_true
		type named str
	param if_false
		type named str
	returns
		type named void
	if
		pls get value
		then
			pls do print the if_true
		else
			pls do print the if_false

local politely_agree
	bind fn bool_printer as callable
		_
		string "i would indeed like to agree."
		_

pls do ~ the politely_agree
	true
	string "what?! utter BULLSHIT!"

pls do ~ the politely_agree
	false
	string "what?! utter BULLSHIT!"



note the above is roughly equivalent to following JS
	
	function createCounter() {
		let count = 0;
		return function() {
			return ++count;
		};
	}




note these things aren't supported (yet?)

	// Simple loop
	for (let i = 0; i < 3; i++) {
		console.log(i);
	}

	// Arrow functions and array methods
	const evenNumbers = numbers.filter(n => n % 2 === 0);
	const doubled = numbers.map(n => n * 2);
	const sum = numbers.reduce((acc, n) => acc + n, 0);

	// Object destructuring
	const {name: userName, age: userAge} = user;

	// Template literals
	const message = `User ${userName} is ${userAge} years old`;

	// Default parameters and rest operator
	function createUser(name, age = 18, ...hobbies) {
		return {
			name,
			age,
			hobbies
		};
	}

	// Promises and async operations
	function fetchData(url) {
		return new Promise((resolve, reject) => {
			setTimeout(() => {
				if (url) {
					resolve(`Data from ${url}`);
				} else {
					reject(new Error("No URL provided"));
				}
			}, 1000);
		});
	}

	// Async/await
	async function getData() {
		try {
			const data = await fetchData("https://api.example.com");
			return data;
		} catch (error) {
			console.error("Error:", error.message);
			return null;
		}
	}

	// Classes with inheritance
	class Animal {
		constructor(name) {
			this.name = name;
		}
		
		speak() {
			return `${this.name} makes a sound`;
		}
	}

	class Dog extends Animal {
		constructor(name, breed) {
			super(name);
			this.breed = breed;
		}
		
		speak() {
			return `${this.name} barks`;
		}
		
		static getBestFriend() {
			return "Human";
		}
	}

	// Closures and higher-order functions
	function createCounter() {
		let count = 0;
		return function() {
			return ++count;
		};
	}

	const counter = createCounter();

	// Function composition
	const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);
	const addOne = x => x + 1;
	const multiplyByTwo = x => x * 2;
	const square = x => x * x;

	const complexOperation = pipe(addOne, multiplyByTwo, square);

	// Proxies for meta-programming
	const observableObject = new Proxy({}, {
		set(target, property, value) {
			console.log(`Setting ${property} to ${value}`);
			target[property] = value;
			return true;
		},
		get(target, property) {
			console.log(`Getting ${property}`);
			return target[property];
		}
	});

	// Generators
	function* fibonacci(limit) {
		let a = 0, b = 1;
		while (a < limit) {
			yield a;
			[a, b] = [b, a + b];
		}
	}

	// Symbol usage for private-like properties
	const _private = Symbol('private');
	class SecureClass {
		constructor(value) {
			this[_private] = value;
		}
		
		getValue() {
			return this[_private];
		}
	}

	// Advanced async patterns - concurrent execution
	async function processMultipleRequests(urls) {
		const promises = urls.map(url => fetchData(url));
		const results = await Promise.allSettled(promises);
		
		return results.map((result, index) => ({
			url: urls[index],
			status: result.status,
			data: result.status === 'fulfilled' ? result.value : null,
			error: result.status === 'rejected' ? result.reason.message : null
		}));
	}

	// WeakMap for memory-efficient associations
	const privateData = new WeakMap();
	class DataContainer {
		constructor(data) {
			privateData.set(this, data);
		}
		
		getData() {
			return privateData.get(this);
		}
	}

	// Custom error handling
	class ValidationError extends Error {
		constructor(message, field) {
			super(message);
			this.name = 'ValidationError';
			this.field = field;
		}
	}

	// Decorator pattern (experimental)
	function measureTime(target, propertyKey, descriptor) {
		const originalMethod = descriptor.value;
		descriptor.value = function(...args) {
			const start = performance.now();
			const result = originalMethod.apply(this, args);
			const end = performance.now();
			console.log(`${propertyKey} took ${end - start} milliseconds`);
			return result;
		};
		return descriptor;
	}

	// Usage examples
	const dog = new Dog("Rex", "Golden Retriever");
	const fibSeq = [...fibonacci(100)];
	observableObject.test = "value";
	const result = complexOperation(5); // ((5 + 1) * 2)^2 = 144


