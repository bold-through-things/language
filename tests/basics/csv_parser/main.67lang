note the task given
	Read a newline-separated list of strings (simulate lines of a CSV file).
	Assume the first line is a comma-separated list of headers.
	Parse each subsequent line into a “row object” (i.e. a map from header → value).
	Store all rows in a list, and then:
	Print each row’s "name" field (or whatever is in column 0, if you don’t want to special-case).
	Count how many rows have "age" > 30, assuming one of the columns is age.

local lines
	do stdin
	# okay i am seeing a reason to stop treating builtins as special, or at the very least to expose them in the scope object

local lines
	do split the lines
		string "\n"

local i
	int 0
local header
	list
		type str
local rows
	list
		type dict
			type str for K
			type str for V
for line in
	get lines
	do
		if
			do eq
				get i
				int 0
		then
			do split the line into header
				string ","
		else
			local zipped_data
				do zip
					get header
					do split the line
						string ","
			
			local row
				dict
					type str for K
					type str for V
			
			for kv in
				get zipped_data
				do
					do # the row
						get 0 from kv
						get 1 from kv
			
			do push the rows
				get row
		
		do i
			local _please_fix_the_fucking_varargs_add
				type int
				do add
					get i
					int 1

for row in
	get rows
	do
		do print
			get # from row
				string "name"

local age_over_30
	int 0
for row in
	get rows
	do
		if
			note TODO - the test case should probably strain this asc
				on what happens if age is 30
			do asc
				do int:parse
					do # the row
						string "age"
				int 30
		then
			do add into age_over_30
				get age_over_30
				int 1

do print
	get age_over_30
