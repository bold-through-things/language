

// 67 CLAUSE THIS FILE WAS AUTOGENERATED DO NOT EDIT

import { Fixed, VarOrTerminated, Schema, parse_tokens, Parsed_clause } from "../compiler/src_ts/utils/new_parser.ts";

function must<T>(not_null: T | null | undefined, message: string): T {
  if (not_null === null || not_null === undefined) {
    throw new Error(message);
  }
  return not_null;
}

export class clause {
  schema = {
    clause: new Fixed(1, [] /* TODO */, undefined),
    varargs: new Fixed(0, [] /* TODO */, undefined),
    fixed: new Fixed(1, [] /* TODO */, undefined),
  };
  parse(tokens: string[]) {

    const parsed = parse_tokens(tokens, this.schema);

    type Focus_type = {
      value: string[];
      children: {
        [key: string]: Parsed_clause<Schema["any"]>[];
      } | null;
    }

    let focus: Focus_type = {
      value: [],
      children: parsed,
    };

    let result; // TypeScript better infer ts

    let parent_focus = focus ;
    let parent_result; // TypeScript better infer ts
    if (focus.children != null && "clause" in focus.children && focus.children["clause"].length > 0) {
      parent_result = result;
      parent_focus = focus;
      {
        let result;
        let focus: Focus_type = parent_focus;
        focus = must(focus.children?.["clause"]?.[0], "focus clause not found");
        result = {
        ["kind"]: "clause" as const,
        ["clause"]: must(focus.value[0], "argument not found"),
        };

        parent_result = result;
      }
      result = parent_result;

      {
        let result;
        parent_result = result;
        parent_focus = focus;
        {
          let result;
          let focus: Focus_type = parent_focus;
          if (focus.children != null && "fixed" in focus.children && focus.children["fixed"].length > 0) {
            focus = must(focus.children?.["fixed"]?.[0], "focus clause not found");
            result = {
            ["kind"]: "fixed" as const,
            ["fixed"]: must(focus.value[0], "argument not found"),
            };

          }

          if (focus.children != null && "varargs" in focus.children && focus.children["varargs"].length > 0) {
            focus = must(focus.children?.["varargs"]?.[0], "focus clause not found");
            result = {
            ["kind"]: "varargs" as const,
            };

          }


          if (result === undefined) {
            throw new Error("clause was not provided");
          }
    
          parent_result = result;
        }
        result = parent_result;

        parent_result = result;
      }
      if (result === undefined) { throw new Error("merging into `undefined`"); }
      result = { ...result, ...parent_result ?? {} };

    }


    if (result === undefined) {
      throw new Error("clause was not provided");
    }
    
    return result;
  }
}


export class focus {
  schema = {
    focus: new Fixed(1, [] /* TODO */, undefined),
  };
  parse(tokens: string[]) {

    const parsed = parse_tokens(tokens, this.schema);

    type Focus_type = {
      value: string[];
      children: {
        [key: string]: Parsed_clause<Schema["any"]>[];
      } | null;
    }

    let focus: Focus_type = {
      value: [],
      children: parsed,
    };

    let result; // TypeScript better infer ts

    let parent_focus = focus ;
    let parent_result; // TypeScript better infer ts
    if (focus.children != null && "focus" in focus.children && focus.children["focus"].length > 0) {
      focus = must(focus.children?.["focus"]?.[0], "focus clause not found");
      result = {
      ["kind"]: "focus" as const,
      ["focus"]: must(focus.value[0], "argument not found"),
      };

    }


    if (result === undefined) {
      throw new Error("clause was not provided");
    }
    
    return result;
  }
}

