#!/usr/bin/env -S deno run --allow-run --allow-read --allow-write --unstable-raw-imports

// find all *.clause files

import { read_file, walk_recursive } from "../certain/paths.ts";
import { Tree_parser } from "../compiler/src_ts/core/tree_parser.ts";
import { cut, IndentedStringIO, prefix_removed } from "../compiler/src_ts/utils/strutil.ts";

import { Fixed, VarOrTerminated, Schema } from "../compiler/src_ts/utils/new_parser.ts";
import { Node } from "../compiler/src_ts/core/node.ts";

const RESULT = "result";
const PARENT_RESULT = "parent_result";
const FOCUS = "focus";
const PARENT_FOCUS = "parent_focus";

const MARKER = "// 67 CLAUSE THIS FILE WAS AUTOGENERATED DO NOT EDIT"

class Rule_engine__exhaustive {
  constructor() {
    // ...
  }

  async to_TypeScript(): Promise<string> {
    return `
if (${RESULT} === undefined) {
  throw new Error("clause was not provided");
}
    `;
  }
}

class Rule_engine__focus {
  constructor(public focus_clause: string) {
    // ...
  }
  async to_TypeScript(): Promise<string> {
    return `${FOCUS} = must(${FOCUS}.children?.["${this.focus_clause}"]?.[0], "focus clause not found");`;
  }
}

class Rule_engine__merge {
  constructor(public items: Rule_engine_item[]) {
    // ...
  }
  
  async to_TypeScript(): Promise<string> {
    const indented = new IndentedStringIO("  ");
    indented.writeline(`{`);
    await indented.with_indent_a(async () => {
      indented.writeline(`let ${RESULT};`);
      for (const action of this.items) {
        indented.writeline(await action.to_TypeScript());
      }
      indented.writeline(`${PARENT_RESULT} = ${RESULT};`);
    });
    indented.writeline(`}`);
    indented.writeline(`if (${RESULT} === undefined) { throw new Error("merging into \`undefined\`"); }`);
    indented.writeline(`${RESULT} = { ...${RESULT}, ...${PARENT_RESULT} ?? {} };`);
    return indented.to_string();
  }
}

class Rule_engine__ctx {
  constructor(public items: Rule_engine_item[]) {
    // ...
  }

  async to_TypeScript(): Promise<string> {
    const indented = new IndentedStringIO("  ");
    indented.writeline(`${PARENT_RESULT} = ${RESULT};`) // i fucking hate your JavaScript
    indented.writeline(`${PARENT_FOCUS} = ${FOCUS};`)
    indented.writeline(`{`);
    await indented.with_indent_a(async () => {
      // indented.writeline(`const ctx = Object.create(parent_ctx);`);
      indented.writeline(`let ${RESULT};`); // important that we shadow it so that subrules can do `exhaustive` down below
      indented.writeline(`let ${FOCUS}: Focus_type = ${PARENT_FOCUS};`);
      for (const action of this.items) {
        indented.writeline(await action.to_TypeScript());
      }
      indented.writeline(`${PARENT_RESULT} = ${RESULT};`);
    });
    indented.writeline(`}`);
    indented.writeline(`${RESULT} = ${PARENT_RESULT};`)
    return indented.to_string();
  }
}

class Rule_engine__object {
  constructor(public items: Rule_engine_item[]) {
    // ...
  }
  
  async to_TypeScript(): Promise<string> {
    const indented = new IndentedStringIO("  ");
    indented.writeline(`${RESULT} = {`);
    for (const action of this.items) {
      indented.writeline(await action.to_TypeScript());
    }
    indented.writeline(`};`);
    return indented.to_string();
  }
}

class Rule_engine__lit {
  constructor(public key: string, public value: string) {
    // ...
  }

  async to_TypeScript(): Promise<string> {
    return `["${this.key}"]: "${this.value}" as const,`;
  }
}

class Rule_engine__set_arg {
  constructor(public key: string, public arg_index: number) {
    // ...
  }

  async to_TypeScript(): Promise<string> {
    // TODO could check `arg_index` valid for the target `fixed`
    return `["${this.key}"]: must(${FOCUS}.value[${this.arg_index}], "argument not found"),`;
  }
}

class Rule_engine__rule_has {
  constructor(public clause_name: string, public items: Rule_engine_item[]) {
    // ...
  }

  async to_TypeScript(): Promise<string> {
    const indented = new IndentedStringIO("  ");
    indented.writeline(`if (${FOCUS}.children != null && "${this.clause_name}" in ${FOCUS}.children && ${FOCUS}.children["${this.clause_name}"].length > 0) {`);
    await indented.with_indent_a(async () => {
      for (const action of this.items) {
        indented.writeline(await action.to_TypeScript());
      }
    });
    indented.writeline(`}`);
    return indented.to_string();
  }
}

type Rule_engine_item = 
  Rule_engine__rule_has | 
  Rule_engine__focus | 
  Rule_engine__merge | 
  Rule_engine__ctx | 
  Rule_engine__object |
  Rule_engine__lit |
  Rule_engine__set_arg |
  Rule_engine__exhaustive

async function Schema_to_TypeScript(schema: Schema | null): Promise<string> {
  if (schema === null) {
    return "undefined";
  }

  const indented = new IndentedStringIO("  ");
  indented.writeline("{");
  await indented.with_indent_a(async () => {
    for (const [key, value] of Object.entries(schema)) {
      if (value instanceof Fixed) {
        indented.writeline(`${key}: new Fixed(${value.count}, [] /* TODO */, ${await Schema_to_TypeScript(value.subParser ?? null)}),`);
      } else if (value instanceof VarOrTerminated) {
        indented.writeline(`${key}: new VarOrTerminated(null /* TODO */, [] /* TODO */, ${await Schema_to_TypeScript(value.subParser ?? null)}),`);
      }
    }
  });
  indented.write("}");
  return indented.to_string();
}

type Parser = {
  schema: Schema
  name: string
  rules: Rule_engine_item[]
}

async function Parser_to_TypeScript(parser: Parser): Promise<string> {
  const indented = new IndentedStringIO("  ");
  indented.writeline(`export class ${parser.name} {`);
  await indented.with_indent_a(async () => {
    // TODO make `static` (due to name collisions this is not straightforward since the `parser.name` could equal `${FOCUS}` or some shit
    indented.writeline(`schema = ${await Schema_to_TypeScript(parser.schema)};`); 
    indented.writeline(`parse(tokens: string[]) {`);
    await indented.with_indent_a(async () => {
      indented.write(`
const parsed = parse_tokens(tokens, this.schema);

type Focus_type = {
  value: string[];
  children: {
    [key: string]: Parsed_clause<Schema["any"]>[];
  } | null;
}

let ${FOCUS}: Focus_type = {
  value: [],
  children: parsed,
};

let ${RESULT}; // TypeScript better infer ts

let ${PARENT_FOCUS} = ${FOCUS} ;
let ${PARENT_RESULT}; // TypeScript better infer ts
`        
      )
      for (const rule of parser.rules) {
        indented.writeline(await rule.to_TypeScript());
      }
      indented.writeline(`return result;`);
    });
    indented.writeline(`}`);
  });
  indented.writeline(`}`);
  return indented.to_string();
}

function path_from_to(from: string, to: string): string {
  const from_parts = from.split("/");
  const to_parts = to.split("/");

  // find common prefix
  let i = 0;
  while (i < from_parts.length && i < to_parts.length && from_parts[i] === to_parts[i]) {
    i++;
  }

  const up_moves = from_parts.length - i - 2; // uhh wtf
  const down_moves = to_parts.slice(i);

  const parts: string[] = [];
  for (let j = 0; j < up_moves; j++) {
    parts.push("..");
  }
  parts.push(...down_moves);

  return parts.join("/");
}

function imports(path: string): string {
  return `
${MARKER}

import { Fixed, VarOrTerminated, Schema, parse_tokens, Parsed_clause } from "${path_from_to(path, "compiler/src_ts/utils/new_parser.ts")}";

function must<T>(not_null: T | null | undefined, message: string): T {
  if (not_null === null || not_null === undefined) {
    throw new Error(message);
  }
  return not_null;
}
`;
}

async function clause_def_file_to_TypeScript(path: string, content: string): Promise<string> {
  function handle_clause(node: Node, schema: Schema) {
    // "clause <clause_name> fixed 1"
    const args = node.content.split(" ");
    const clause_name = args[1];
    const mode = args[2];
    const value = args[3];
    if (clause_name === undefined || mode === undefined) {
      throw new Error(`clause invalid \`${node.content}\``);
    }
    const temp_subparser: Schema = {};
    for (const child of node.children) {
      if (child.content.trim() === "" || child.content.startsWith("note ")) {
        continue;
      }
      handle_clause(child, temp_subparser);
    }
    const subparser = Object.keys(temp_subparser).length === 0 ? null : temp_subparser;
    if (mode === "fixed") {
      if (value === undefined || isNaN(parseInt(value))) {
        throw new Error(`\`fixed N\` needs number of arguments \`${node.content}\``);
      }
      schema[clause_name] = new Fixed(parseInt(value), [], subparser ?? undefined);
    } else if (mode === "varargs") {
      schema[clause_name] = new VarOrTerminated(null, [], subparser ?? undefined);
    } else {
      throw new Error(`unknown \`${mode}\` in \`${node.content}\``);
    }
  }

  function handle_rule_engine_node(node: Node): Rule_engine_item {
    // "rule has $clause_name"
    const content__rule_has = prefix_removed(node.content, "rule has ");
    if (content__rule_has !== null) {
      const clause_name = content__rule_has.trim();
      const items: Rule_engine_item[] = [];
      for (const child of node.children) {
        const item = handle_rule_engine_node(child);
        items.push(item);
      }
      return new Rule_engine__rule_has(clause_name, items);
    }

    const content__focus = prefix_removed(node.content, "focus ");
    if (content__focus !== null) {
      const focus_clause = content__focus.trim();
      return new Rule_engine__focus(focus_clause);
    }

    const content__merge = prefix_removed(node.content, "merge");
    if (content__merge !== null) {
      const items: Rule_engine_item[] = [];
      for (const child of node.children) {
        const item = handle_rule_engine_node(child);
        items.push(item);
      }
      return new Rule_engine__merge(items);
    }

    const content__ctx = prefix_removed(node.content, "ctx");
    if (content__ctx !== null) {
      const items: Rule_engine_item[] = [];
      for (const child of node.children) {
        const item = handle_rule_engine_node(child);
        items.push(item);
      }
      return new Rule_engine__ctx(items);
    }

    const content__object = prefix_removed(node.content, "object");
    if (content__object !== null) {
      const items: Rule_engine_item[] = [];
      for (const child of node.children) {
        const item = handle_rule_engine_node(child);
        items.push(item);
      }
      return new Rule_engine__object(items);
    }

    const content__lit = prefix_removed(node.content, "lit kind ");
    if (content__lit !== null) {
      const value = content__lit.trim();
      return new Rule_engine__lit("kind", value);
    }

    const content__set = prefix_removed(node.content, "set ");
    if (content__set !== null) {
      // "set <key> arg <index>"
      const args = content__set.trim().split(" ");
      const key = args[0];
      if (key === undefined || args[1] !== "arg" || args[2] === undefined || isNaN(parseInt(args[2]))) {
        throw new Error(`wrong set syntax \`${node.content}\``);
      }
      const arg_index = parseInt(args[2]);
      return new Rule_engine__set_arg(key, arg_index);
    }

    if (node.content.trim() === "exhaustive") {
      return new Rule_engine__exhaustive();
    }

    throw new Error(`unknown item for rule engine \`${node.content}\``);
  }

  const tree = new Tree_parser({
    top_level: "67",
  }).parse_tree(content);

  const parsers: Parser[] = [];
  
  for (const node of tree.children) {
    if (node.content.startsWith("parser ")) {
      const parser_node = node;
      const parser: Parser = {
        schema: {},
        name: cut(parser_node.content, " ")[1],
        rules: []
      }
      parsers.push(parser);
      for (const node of parser_node.children) {
        if (node.content.trim() === "" || node.content.startsWith("note ")) {
          continue;
        }
        if (node.content.startsWith("clause ")) {
          const clause_node = node;
          handle_clause(clause_node, parser.schema);
          continue;
        }
        const rule_node = node;
        const rule_item = handle_rule_engine_node(rule_node);
        parser.rules.push(rule_item);
      }
    } else {
      if (node.content.trim() === "" || node.content.startsWith("note ")) {
        continue;
      }
      throw new Error(`unexpected \`${node.content}\``);
    }
  }

  return `
${imports(path)}
${(await Promise.all(parsers.map(async (p) => await Parser_to_TypeScript(p)))).join("\n\n")}
`
}

async function main() {
  const files: string[] = [];
  for await (const entry of walk_recursive(".")) {
    if (entry.endsWith(".clause")) {
      files.push(entry);
    }
  }

  for (const path of files) {
    const content = await read_file(path);
    if (content === null) {
      throw new Error(`Failed to read file: ${path}`);
    }
    const out_path = path.replace(/\.clause$/, "_clause.ts");
    const out_content = await clause_def_file_to_TypeScript(path, content);

    const existing_content = (await read_file(out_path)) ?? MARKER;
    if (!existing_content.trim().startsWith(MARKER)) {
      throw new Error(`file ${out_path} exists and is not generated by our system`);
    }

    await Deno.writeTextFile(out_path, out_content);
  }
}

if (import.meta.main) {
    main();
}